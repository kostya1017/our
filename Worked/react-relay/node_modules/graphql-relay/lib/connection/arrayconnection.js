
/**
 *  Copyright (c) 2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

var _Promise = require('babel-runtime/core-js/promise')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.connectionFromArray = connectionFromArray;
exports.connectionFromPromisedArray = connectionFromPromisedArray;
exports.cursorForObjectInConnection = cursorForObjectInConnection;

var _utilsBase64Js = require('../utils/base64.js');

/**
 * A simple function that accepts an array and connection arguments, and returns
 * a connection object for use in GraphQL. It uses array offsets as pagination,
 * so pagination will only work if the array is static.
 */

function connectionFromArray(data, args) {
  var edges = data.map(function (value, index) {
    return { cursor: offsetToCursor(index), node: value };
  });
  var before = args.before;

  // Slice with cursors
  var after = args.after;
  var first = args.first;
  var last = args.last;
  var begin = Math.max(getOffset(after, -1), -1) + 1;
  var end = Math.min(getOffset(before, edges.length + 1), edges.length + 1);
  edges = edges.slice(begin, end);
  if (edges.length === 0) {
    return emptyConnection();
  }

  // Save the pre-slice cursors
  var firstPresliceCursor = edges[0].cursor;
  var lastPresliceCursor = edges[edges.length - 1].cursor;

  // Slice with limits
  if (first !== null && first !== undefined) {
    edges = edges.slice(0, first);
  }
  if (last !== null && last !== undefined) {
    edges = edges.slice(-last);
  }
  if (edges.length === 0) {
    return emptyConnection();
  }

  // Construct the connection
  var firstEdge = edges[0];
  var lastEdge = edges[edges.length - 1];
  return {
    edges: edges,
    pageInfo: {
      startCursor: firstEdge.cursor,
      endCursor: lastEdge.cursor,
      hasPreviousPage: firstEdge.cursor !== firstPresliceCursor,
      hasNextPage: lastEdge.cursor !== lastPresliceCursor
    }
  };
}

/**
 * A version of the above that takes a promised array, and returns a promised
 * connection.
 */

function connectionFromPromisedArray(dataPromise, args) {
  return dataPromise.then(function (data) {
    return connectionFromArray(data, args);
  });
}

/**
 * Helper to get an empty connection.
 */
function emptyConnection() {
  return {
    edges: [],
    pageInfo: {
      startCursor: null,
      endCursor: null,
      hasPreviousPage: false,
      hasNextPage: false
    }
  };
}

var PREFIX = 'arrayconnection:';

/**
 * Creates the cursor string from an offset.
 */
function offsetToCursor(offset) {
  return (0, _utilsBase64Js.base64)(PREFIX + offset);
}

/**
 * Rederives the offset from the cursor string.
 */
function cursorToOffset(cursor) {
  return parseInt((0, _utilsBase64Js.unbase64)(cursor).substring(PREFIX.length), 10);
}

/**
 * Return the cursor associated with an object in an array.
 */

function cursorForObjectInConnection(data, object) {
  var offset = data.indexOf(object);
  if (offset === -1) {
    return null;
  }
  return offsetToCursor(offset);
}

/**
 * Given an optional cursor and a default offset, returns the offset
 * to use; if the cursor contains a valid offset, that will be used,
 * otherwise it will be the default.
 */
function getOffset(cursor, defaultOffset) {
  if (cursor === undefined || cursor === null) {
    return defaultOffset;
  }
  var offset = cursorToOffset(cursor);
  if (isNaN(offset)) {
    return defaultOffset;
  }
  return offset;
}